//go:build gnob

// Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.
//   $ bundle -o gnob.go -dst . -pkg main -prefix Gnob -tags gnob ./internal/gnoblib

package main

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"log/slog"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"runtime"
	"runtime/debug"
	"slices"
	"strings"
	"text/template"
	"time"
	"unicode"
)

// # Go No-Build Tool
//
// ## Overview
//
// `gnob` is a lightweight build system that exists as a single Go file.
// It allows you to orchestrate your builds using only the `go` command, and nothing more.
//
// ### Philosophy
//
// `gnob` addresses a common problem in Go projects: the need for a build tool that doesn't
// require additional installations beyond the Go toolchain itself. Unlike Make, Bazel,
// or Mage, gnob requires no external dependencies.
//
// ### Key Features
//
//   - Single-file distribution: Copy [gnob.go](gnob.go) into your project, no installation required
//   - Self-rebuilding: Automatically rebuilds itself when source files change
//   - Command chaining: Build complex command pipelines with proper error handling
//   - Makefile-style targets: Create reusable build tasks with dependencies
//   - JSON processing: Built-in support for processing JSON data in pipelines
//   - Structured logging: Integrated logging for build process visibility
//
// ### Prior Art
//
// This project is inspired primarily by [nob.h](https://github.com/tsoding/nob.h)
// And also [Mage](https://magefile.org/).
//
// ## Installation
//
// First, copy [gnob.go](gnob.go) into your project.
// It's a good idea to put this into a `build/` subfolder
// so it doesn't interact with the rest of your program.
//
// **Example:**
// ```
// .
// |-- build/
// |   |-- gnob.go
// |   |-- main.go
// |-- main.go
// |-- ...
// ```
//
// You can then create any number of files in the `build/` folder, using the `.go` extension.
//
// ## Usage
//
// To use `gnob.go`, you should create `main.go` along side `gnob.go` with the follow skeleton:
//
// ```go
// //go:build gnob
//
// package main
//
// //go:generate go build -o gnob -tags gnob ./...
//
// // Most functionality is available through member objects of GnobLib
// // This allows the functions to be isolated in a single namespace.
// //
// // You can create some convenience variable to alias these fields.
// var gnob = GnobLib.Main
//
// // The GnobLib.Main.GoRebuildYourself function automatically rebuilds the
// //gnob binary when source files are newer than the executable:
//
// func main() {
// 	// Rebuild if any *.go files are newer than the gnob binary.
// 	gnob.GoRebuildYourself("*.go")
//
// 	// Rebuild only if specific files are newer than the gnob binary.
// 	gnob.GoRebuildYourself("main.go", "build.go", "tasks.go")
//
// 	// Your build logic here
// }
//
// ```
//
// The `GnobLib.Main.GoRebuildYourself` function will rebuild your project if any of the files matching `*.go` are newer than the `gnob` binary.
//
// To bootstrap the gnob binary, run
//
// ```sh
// go generate -C ./build .
// ```
//
// From now on, you can run `./build/gnob` and it will rebuild the `./build/gnob` binary if necessary before it runs your build tasks.
//
// ## Build Helpers
//
// ### Commands and Pipes
//
// While you can already use the `exec` package to run external commands,
// It is often helpful to have a more convenient way to run commands and pipes.
//
// `gnob` provides a way to construct a chain of commands that pipe the outputs
// of one command into the inputs of the next, and execute them all at once.
//
// #### Command Execution Examples
//
// Simple command execution:
//
// ```go
// if err := GnobLib.Cmd.Exec(ctx, "go", "build", "./...").Run(); err != nil {
// 	GnobLogger.Error("failed to build", "error", err)
// 	return err
// }
//
// ```
//
// Command with output capture:
//
// ```go
// var output bytes.Buffer
// if err := GnobLib.Cmd.ExecOpt(ctx, GnobLib.Cmd.ExecOptions(
// 	GnobLib.Cmd.WithStdout(&output),
// ), "git", "rev-parse", "HEAD").Run(); err != nil {
// 	return err
// }
// commitHash := strings.TrimSpace(output.String())
// GnobLogger.Info("commit hash", "hash", commitHash)
//
// ```
//
// Command pipeline (equivalent to: echo "hello" | tr '[:lower:]' '[:upper:]' | wc -c):
//
// ```go
// var result bytes.Buffer
// p := GnobLib.Cmd.Exec(ctx, "echo", "hello")
// p = p.Pipe("tr", "[:lower:]", "[:upper:]")
// p = p.PipeOpt(GnobLib.Cmd.WithStdout(&result), "wc", "-c")
// if err := p.Run(); err != nil {
// 	return err
// }
// GnobLogger.Info("result", "result", result.String())
//
// ```
//
//
// JSON processing in pipeline:
//
// ```go
// type Config struct {
// 	Name    string `json:"name"`
// 	Version string `json:"version"`
// }
// var config Config
// if err := GnobLib.Cmd.ExecOpt(ctx, GnobLib.Cmd.WithStdoutJSONDecoder(&config),
// 	"cat", "package.json").Run(); err != nil {
// }
// GnobLogger.Info("config",
// 	"name", config.Name,
// 	"version", config.Version,
// )
//
// ```
//
// #### Full Example
//
// ```go
// //go:build gnob
//
// package main
//
// import (
// 	"bytes"
// 	"context"
// 	"encoding/json"
// 	"fmt"
// 	"os"
// 	"strings"
// )
//
// //go:generate go build -o gnob -tags gnob ./...
//
// // convenience variables
// var (
// 	logger = GnobLogger
// 	cmd    = GnobLib.Cmd
// )
//
// type MyObject struct {
// 	Msg string `json:"msg"`
// }
//
// func main() {
// 	ctx := context.Background()
// 	if err := run(ctx); err != nil {
// 		fmt.Println(err)
// 		os.Exit(1)
// 	}
// }
//
// func run(ctx context.Context) error {
// 	var (
// 		obj MyObject
// 		buf bytes.Buffer
// 	)
//
// 	// The following is essentially:
// 	// echo '{"msg":"hello world"} | cat | jq -r .msg
// 	p := cmd.ExecOpt(ctx,
// 		// Here we are tapping the output of the first command
// 		// and unmarshalling it into our 'out' object.
// 		// This is tougher to do in bash alone.
// 		cmd.WithStdoutJSONDecoder(&obj),
// 		"bash", "-c", `echo '{"msg":"hello world"}'`)
// 	p = p.Pipe("cat")
// 	p = p.PipeOpt(cmd.WithStdout(&buf),
// 		"jq", "-r", ".msg")
// 	if err := p.Run(); err != nil {
// 		return err
// 	}
// 	logger.Info("writing buffer.out", "msg", strings.TrimSpace(buf.String()))
// 	if err := os.WriteFile("buffer.out", buf.Bytes(), 0o644); err != nil {
// 		return fmt.Errorf("write buffer.out: %w", err)
// 	}
//
// 	logger.Info("marshalling json object", "obj", obj)
// 	outJS, err := json.MarshalIndent(obj, "", "  ")
// 	if err != nil {
// 		return fmt.Errorf("marshal JSON: %w", err)
// 	}
//
// 	logger.Info("writing json", "js", string(outJS))
// 	if err = os.WriteFile("buffer.json", outJS, 0o644); err != nil {
// 		return fmt.Errorf("write buffer.json: %w", err)
// 	}
// 	return nil
// }
//
// ```
//
// ### Makefile-Style Targets
//
// While you can use the main function to build your entire project, it is often helpful
// to have a Makefile-like target system so that you can create tasks that can be run.
//
// ```go
// //go:build gnob
//
// package main
//
// import (
// 	"context"
// 	"fmt"
// )
//
// //go:generate go build -o gnob -tags gnob ./...
//
// func main() {
// 	GnobLib.Main.GoRebuildYourself("*.go")
// 	mf := GnobLib.Makefile.New(Default, TaskOne, TaskTwo, TaskThree)
// 	mf.Run(context.Background())
// }
//
// var Default = GnobMakeTarget{
// 	Name:     "default",
// 	Desc:     "default target",
// 	LongDesc: "This is the default target",
// 	Default:  true,
// 	Body: func(ctx context.Context, mf *GnobMakefile) error {
// 		// Run dependencies first
// 		if err := mf.Depend(ctx, "task1", "task2", "task3"); err != nil {
// 			return err
// 		}
// 		// Now perform the default action
// 		fmt.Println("Default Target")
// 		return nil
// 	},
// }
//
// var TaskOne = GnobMakeTarget{
// 	Name:     "task1",
// 	Desc:     "Task1",
// 	LongDesc: "This is the first task",
// 	Body: func(ctx context.Context, mf *GnobMakefile) error {
// 		fmt.Println("Task #1")
// 		return nil
// 	},
// }
// var TaskTwo = GnobMakeTarget{
// 	Name:     "task2",
// 	Desc:     "Task2",
// 	LongDesc: "This is the second task",
// 	Body: func(ctx context.Context, mf *GnobMakefile) error {
// 		fmt.Println("Task #2")
// 		return nil
// 	},
// }
// var TaskThree = GnobMakeTarget{
// 	Name:     "task3",
// 	Desc:     "Task3",
// 	LongDesc: "This is the third task",
// 	Body: func(ctx context.Context, mf *GnobMakefile) error {
// 		fmt.Println("Task #3")
// 		return nil
// 	},
// }
//
// ```
//
// And the result of running the `default` target should be:
//
// ```shell
// $ ./gnob -help ## Listing Targets
// Usage: gnob [-help] [target]
// Targets:
// * default   default target
//   task1     Task1
//   task2     Task2
//   task3     Task3
//
// * (default target)
//
// $ ./gnob -help default ## Help on Target 'default'
// gnob default:
//
// default target
// This is the default target
//
// $ ./gnob default ## Run 'default'
// Task #1
// Task #2
// Task #3
// Default Target
// ```
//
//

// ExecOption is the interface for options to customize the command.
type GnobExecOption interface {
	apply(*GnobcmdOptions)
}

// ExecOptionFunc is an adapter to allow the use of ordinary functions as ExecOption.
type GnobExecOptionFunc func(*GnobcmdOptions)

func (fn GnobExecOptionFunc) apply(opts *GnobcmdOptions) {
	fn(opts)
}

// WithStdout sets the standard output for the command.
func (Gnob_cmd) WithStdout(stdout io.Writer) GnobExecOption {
	return GnobExecOptionFunc(func(opts *GnobcmdOptions) {
		opts.stdout = stdout
	})
}

// WithStdoutJSONDecoder decodes the standard output into the given object.
// The object must be a pointer to a struct.
func (Gnob_cmd) WithStdoutJSONDecoder(out any) GnobExecOption {
	var buf bytes.Buffer
	return GnobExecOptionFunc(func(opts *GnobcmdOptions) {
		opts.stdout = &buf
		opts.onExit = append(opts.onExit, func() {
			_ = json.Unmarshal(buf.Bytes(), out)
		})
	})
}

// WithStderr sets the standard error for the command.
func (Gnob_cmd) WithStderr(stderr io.Writer) GnobExecOption {
	return GnobExecOptionFunc(func(opts *GnobcmdOptions) {
		opts.stderr = stderr
	})
}

// WithStdin sets the standard input for the command.
func (Gnob_cmd) WithStdin(stdin io.Reader) GnobExecOption {
	return GnobExecOptionFunc(func(opts *GnobcmdOptions) {
		opts.stdin = stdin
	})
}

// WithDir sets the working directory for the command.
func (Gnob_cmd) WithDir(dir string) GnobExecOption {
	return GnobExecOptionFunc(func(opts *GnobcmdOptions) {
		opts.workingDir = dir
	})
}

// WithEnvVars sets environment variables for the command.
func (Gnob_cmd) WithEnvVars(env map[string]string) GnobExecOption {
	return GnobExecOptionFunc(func(opts *GnobcmdOptions) {
		if opts.envVars == nil {
			opts.envVars = make(map[string]string)
		}
		for k, v := range env {
			opts.envVars[k] = v
		}
	})
}

// WithNoInheritEnv disables inheriting the parent process's environment variables.
func (Gnob_cmd) WithNoInheritEnv(b bool) GnobExecOption {
	return GnobExecOptionFunc(func(opts *GnobcmdOptions) {
		opts.noInheritEnv = b
	})
}

// ExecOptions combines multiple ExecOption into one.
func (Gnob_cmd) ExecOptions(opts ...GnobExecOption) GnobExecOption {
	return GnobExecOptionFunc(func(co *GnobcmdOptions) {
		for _, o := range opts {
			o.apply(co)
		}
	})
}

type GnobcmdOptions struct {
	noInheritEnv bool
	envVars      map[string]string
	workingDir   string
	stdout       io.Writer
	stderr       io.Writer
	stdin        io.Reader
	onExit       []func()
}

type GnobExec struct {
	prev      *GnobExec
	ctx       context.Context
	cmd       *exec.Cmd
	stderr    bytes.Buffer
	closers   []io.Closer
	onExit    []func()
	exitCodes []int
}

type Gnob_cmd struct {
}

// Exec creates a new command.
// The output of this command can be chained into other commands with Pipe and Pipe2.
// For example:
//
//	Cmd.Exec("echo", "hello").Pipe("wc").Run()
func (c Gnob_cmd) Exec(ctx context.Context, command string, args ...string) *GnobExec {
	return c.ExecOpt(ctx, nil, command, args...)
}

// ExecOpt is like Exec, but you can specify options to customize the command.
// You can also collect multiple options together with ExecOptions.
func (c Gnob_cmd) ExecOpt(ctx context.Context, opt GnobExecOption, command string, args ...string) *GnobExec {
	var o GnobcmdOptions
	if opt != nil {
		opt.apply(&o)
	}
	execCmd := exec.CommandContext(ctx, command, args...)
	if o.workingDir != "" {
		execCmd.Dir = o.workingDir
	}
	environ := make([]string, 0, len(o.envVars))
	if !o.noInheritEnv {
		environ = append(environ, os.Environ()...)
	}
	if len(o.envVars) > 0 {
		for k, v := range o.envVars {
			environ = append(environ, fmt.Sprintf("%s=%s", k, v))
		}
	}
	execCmd.Stdin = o.stdin
	execCmd.Stdout = o.stdout
	execCmd.Stderr = o.stderr
	execCmd.Env = environ
	return &GnobExec{
		cmd:    execCmd,
		ctx:    ctx,
		onExit: o.onExit,
	}
}

// Pipe creates a new command that will be executed after the current command.
// The current command's stdout will be piped to the new command's stdin.
func (e *GnobExec) Pipe(command string, args ...string) *GnobExec {
	return e.PipeOpt(nil, command, args...)
}

// PipeOpt is like Pipe, but you can specify cmdOptions to customize the command.
func (e *GnobExec) PipeOpt(opt GnobExecOption, command string, args ...string) *GnobExec {
	next := GnobLib.Cmd.ExecOpt(e.ctx, opt, command, args...)
	if e.cmd.Stdout != nil {
		if c, ok := e.cmd.Stdout.(io.Closer); ok {
			e.closers = append(e.closers, c)
		}
		pr, pw, err := os.Pipe()
		if err != nil {
			panic(err)
		}
		e.closers = append(e.closers, pw)
		tr := io.TeeReader(pr, e.cmd.Stdout)
		e.cmd.Stdout = pw
		next.cmd.Stdin = tr
		next.closers = append(next.closers, pr)
	} else {
		var err error
		next.cmd.Stdin, err = e.cmd.StdoutPipe()
		if err != nil {
			panic(err)
		}
	}
	return &GnobExec{
		prev: e,
		ctx:  e.ctx,
		cmd:  next.cmd,
	}
}

// Pipe2 creates a new command that will be executed after the current command.
// The current command's stderr will be piped to the new command's stdin.
func (e *GnobExec) Pipe2(command string, args ...string) *GnobExec {
	return e.Pipe2Opt(nil, command, args...)
}

// Pipe2Opt is like Pipe2, but you can specify cmdOptions to customize the command.
func (e *GnobExec) Pipe2Opt(opt GnobExecOption, command string, args ...string) *GnobExec {
	next := GnobLib.Cmd.ExecOpt(e.ctx, opt, command, args...)
	if e.cmd.Stderr != nil {
		if c, ok := e.cmd.Stderr.(io.Closer); ok {
			e.closers = append(e.closers, c)
		}
		pr, pw, err := os.Pipe()
		if err != nil {
			panic(err)
		}
		e.closers = append(e.closers, pw)
		tr := io.TeeReader(pr, e.cmd.Stderr)
		e.cmd.Stderr = pw
		next.cmd.Stdin = tr
		next.closers = append(next.closers, pr)
	} else {
		var err error
		next.cmd.Stdin, err = e.cmd.StderrPipe()
		if err != nil {
			panic(err)
		}
	}
	return &GnobExec{
		prev: e,
		ctx:  e.ctx,
		cmd:  next.cmd,
	}
}

// Run runs the command chain and waits for it to finish.
func (e *GnobExec) Run() error {
	if err := e.Start(); err != nil {
		return err
	}
	return e.Wait()
}

// Start starts the command chain.
// It returns the first error encountered.
// It does not wait for the command to finish, to wait for the command to finish, use Wait.
func (e *GnobExec) Start() error {
	this := e
	if this.cmd.Stderr == nil {
		this.cmd.Stderr = &this.stderr
	} else {
		this.cmd.Stderr = io.MultiWriter(&this.stderr, e.cmd.Stderr)
	}
	var chain []*exec.Cmd
	for this != nil {
		chain = append(chain, this.cmd)
		this = this.prev
	}
	for i := len(chain) - 1; i >= 0; i-- {
		if err := chain[i].Start(); err != nil {
			return err
		}
	}
	return nil
}

// Wait waits for the command chain to finish.
// It returns the entire error chain joined by errors.Join.
// To get the exit code of the last command, use ExitCode.
// To get the exit codes of all commands, use ExitCodes.
func (e *GnobExec) Wait() error {
	this := e
	var chain []*GnobExec
	for this != nil {
		chain = append(chain, this)
		this = this.prev
	}
	var waitErrs []error
	exitCodes := make([]int, 0, len(chain))
	for i := len(chain) - 1; i >= 0; i-- {
		errCh := make(chan error, 1)
		go func() {
			for _, c := range chain[i].closers {
				_ = c.Close()
			}
			errCh <- chain[i].cmd.Wait()
		}()
		select {
		case <-e.ctx.Done():
			return e.ctx.Err()
		case err := <-errCh:
			for _, f := range chain[i].onExit {
				f()
			}
			waitErrs = append(waitErrs, err)
			var exitErr *exec.ExitError
			if errors.As(err, &exitErr) {
				exitCodes = append(exitCodes, exitErr.ExitCode())
				continue
			}
			exitCodes = append(exitCodes, 0)
		}
	}
	e.exitCodes = exitCodes
	if err := errors.Join(waitErrs...); err != nil {
		return fmt.Errorf("command failed (%v): %w\n%s", e.cmd.Args, err, e.stderr.String())
	}
	return nil
}

// ExitCode returns the exit code of the last command.
func (e *GnobExec) ExitCode() int {
	if len(e.exitCodes) == 0 {
		return -1
	}
	return e.exitCodes[len(e.exitCodes)-1]
}

// ExitCodes returns the exit codes of all commands in the chain.
func (e *GnobExec) ExitCodes() []int {
	return e.exitCodes
}

type Gnob_files struct{}

// CopyDirectory copies a directory recursively from src to dst.
// This will overwrite any files in dst if they already exist.
func (f Gnob_files) CopyDirectory(dst, src string) error {
	return filepath.WalkDir(src, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		info, err := d.Info()
		if err != nil {
			return err
		}
		newPath := filepath.Join(dst, strings.TrimPrefix(path, src))

		// Directories
		if info.IsDir() {
			return os.MkdirAll(newPath, info.Mode())
		}

		// Irregular Files
		if !info.Mode().IsRegular() {
			switch d.Type() {
			case os.ModeSymlink:
				var link string
				link, err = os.Readlink(path)
				if err != nil {
					return err
				}
				return f.Symlink(link, newPath)
			default:
				GnobLogger.Warn("[gnob:Copydirectory] ignoring irregular file type", "type", d.Type().String(), "path", path)
				// Skip other irregular file types.
				return nil
			}
		}
		// Regular files
		return f.CopyFile(newPath, path, info.Mode())
	})
}

// Symlink creates a symlink at 'path' pointing to 'link'.
// If 'path' already exists, it will be removed first.
func (f Gnob_files) Symlink(link string, path string) error {
	if f.Exists(path) {
		if err := os.RemoveAll(path); err != nil {
			return err
		}
	}
	return os.Symlink(link, path)
}

func (f Gnob_files) Exists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

// CopyFile copies a file from src to dst.
// if mode is 0, the file is copied with the original permissions of the source.
func (f Gnob_files) CopyFile(dst, src string, mode os.FileMode) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return fmt.Errorf("unable to open file %q: %w", src, err)
	}
	defer srcFile.Close()
	if mode == 0 {
		stat, err := srcFile.Stat()
		if err != nil {
			return fmt.Errorf("unable to stat file %q: %w", src, err)
		}
		mode = stat.Mode()
	}
	dstFile, err := os.OpenFile(dst, os.O_RDWR|os.O_CREATE|os.O_TRUNC, mode.Perm())
	if err != nil {
		return fmt.Errorf("unable to create dest file %q: %w", dst, err)
	}
	_, err = io.Copy(dstFile, srcFile)
	if err != nil {
		_ = dstFile.Close()
		_ = os.Remove(dst)
		return fmt.Errorf("unable to copy %q -> %q: %w", src, dst, err)
	}
	if err = dstFile.Close(); err != nil {
		_ = os.Remove(dst)
		return fmt.Errorf("unable to close dest file %q: %w", dst, err)
	}
	return nil
}

// LatestTimestamp expands glob patterns and returns the maximum modification
// time among all matched files. If no files match, it returns a Zero time.
// If a glob pattern is malformed or a file stat fails unexpectedly, it returns an error.
func (f Gnob_files) LatestTimestamp(files ...string) time.Time {
	var maxTs time.Time
	matchedAny := false

	for _, pattern := range files {
		matches, err := filepath.Glob(pattern)
		if err != nil {
			return time.Time{}
		}
		for _, p := range matches {
			ts := f.modTime(p)
			matchedAny = true
			if ts.After(maxTs) {
				maxTs = ts
			}
		}
	}

	if !matchedAny {
		// No matches: no error per function contract comment.
		return time.Time{}
	}
	return maxTs
}

func (f Gnob_files) modTime(file string) time.Time {
	fi, statErr := os.Stat(file)
	if statErr != nil {
		return time.Time{}
	}
	return fi.ModTime()
}

// TargetNeedsUpdate returns true if the target file is older than any of the
// sources.
func (f Gnob_files) TargetNeedsUpdate(target string, sources ...string) bool {
	a := f.modTime(target)
	b := f.LatestTimestamp(sources...)
	return b.After(a)
}

// Lib is the library of functions used by gnob.
var GnobLib Gnob_lib

// Lib is the library of functions used by gnob.

// Lib is the library of functions used by gnob.
type Gnob_lib struct {
	// Main is the root of the library.
	Main Gnob_root
	// Template is a collection of operations using Go templates.
	Template Gnob_template
	// Files is a collection of operations on files.
	Files Gnob_files
	// Cmd is a collection of operations to run commands.
	Cmd Gnob_cmd
	// Make has operations to construct a Makefile and MakeTargets.
	Makefile Gnob_makefile
}

var (
	GnobLogger = GnobdefaultLogger()
)

func GnobSetLogger(logger *slog.Logger) {
	GnobLogger = logger
}

type Gnob_logHandler struct {
	start  time.Time
	output io.Writer
	*slog.TextHandler
}

func (h *Gnob_logHandler) Handle(_ context.Context, r slog.Record) error {
	var line strings.Builder
	dur := r.Time.Sub(h.start)
	line.WriteString(fmt.Sprintf("[%04d] ", int(dur.Seconds())))
	switch r.Level {
	case slog.LevelDebug:
		line.WriteString("DEBUG ")
	case slog.LevelInfo:
		line.WriteString("INFO  ")
	case slog.LevelWarn:
		line.WriteString("WARN  ")
	case slog.LevelError:
		line.WriteString("ERROR ")
	}
	line.WriteString(r.Message)
	first := true
	if n := r.NumAttrs(); n > 0 {
		line.WriteString(" {")
		r.Attrs(func(attr slog.Attr) bool {
			if !first {
				line.WriteByte(' ')
			}
			line.WriteString(attr.String())
			first = false
			return true
		})
		line.WriteByte('}')
	}
	line.WriteString("\n")
	_, err := h.output.Write([]byte(line.String()))
	return err
}

func GnobdefaultLogger() *slog.Logger {
	opts := &slog.HandlerOptions{
		Level: slog.LevelInfo,
	}
	switch os.Getenv(GnobEnvLogLevel) {
	case "debug":
		opts.Level = slog.LevelDebug
	case "info":
		opts.Level = slog.LevelInfo
	case "warn":
		opts.Level = slog.LevelWarn
	case "error":
		opts.Level = slog.LevelError
	}
	return slog.New(
		&Gnob_logHandler{
			start:       time.Now(),
			output:      os.Stderr,
			TextHandler: slog.NewTextHandler(os.Stderr, opts),
		},
	)
}

const (
	GnobEnvRebuildDisable = "GNOB_REBUILD_DISABLE"
	GnobEnvLogLevel       = "GNOB_LOG_LEVEL"
)

var (
	GnobBinaryName string
	GnobGoCommand  = "go"
)

func (r Gnob_root) GoRebuildYourself(sources ...string) {
	if GnobBinaryName == "" {
		switch runtime.GOOS {
		case "windows":
			GnobBinaryName = "gnob.exe"
		default:
			GnobBinaryName = "gnob"
		}
	}
	if err := r.RebuildYourself(context.Background(), sources...); err != nil {
		GnobLogger.Error("[gnob:rebuild] failed to rebuild", "error", err)
		var exitErr *exec.ExitError
		if errors.As(err, &exitErr) {
			os.Exit(exitErr.ExitCode())
		}
		os.Exit(1)
	}
}

type Gnob_root struct {
}

func (r Gnob_root) RebuildYourself(ctx context.Context, sources ...string) error {
	if os.Getenv(GnobEnvRebuildDisable) != "" {
		GnobLogger.DebugContext(ctx, "[gnob:rebuild] rebuild disabled")
		return nil
	}
	binary, err := filepath.Abs(os.Args[0])
	if err != nil {
		return fmt.Errorf("could not get absolute path of %s: %v", os.Args[0], err)
	}
	name := filepath.Base(binary)
	GnobLogger.DebugContext(ctx, "[gnob:rebuild] binary name", "name", name)

	if name != GnobBinaryName { // run via go run or some other mechanism
		GnobLogger.DebugContext(ctx, "[gnob:rebuild] expected binary name did not match", "name", name, "expected", GnobBinaryName)
		_, err = os.Stat(GnobBinaryName)
		if os.IsNotExist(err) {
			GnobLogger.DebugContext(ctx, "[gnob:rebuild] binary does not exist, rebuilding", "binary", GnobBinaryName)
			return r.rebuild(ctx, GnobBinaryName, sources)
		}
		if err != nil {
			return fmt.Errorf("failed to stat %s: %v", GnobBinaryName, err)
		}
		if err = r.runBinary(ctx, GnobBinaryName); err != nil {
			return fmt.Errorf("failed to run %s: %v", GnobBinaryName, err)
		}
		os.Exit(0)
	}
	sources, err = r.normalizeSources(binary, sources)
	if err != nil {
		return err
	}
	var f Gnob_files
	GnobLogger.DebugContext(ctx, "[gnob:rebuild] testing if gnob needs to be rebuilt", "sources", sources)
	if f.TargetNeedsUpdate(binary, sources...) {
		GnobLogger.DebugContext(ctx, "[gnob:rebuild] gnob must be rebuilt")
		if err = r.rebuild(ctx, binary, sources); err != nil {
			return fmt.Errorf("failed to build %s: %v", binary, err)
		}
		if err = r.runBinary(ctx, binary); err != nil {
			return fmt.Errorf("failed to run %s: %v", binary, err)
		}
		os.Exit(0)
	}
	GnobLogger.DebugContext(ctx, "[gnob:rebuild] gnob is up to date")
	return nil
}

func (r Gnob_root) normalizeSources(bin string, sources []string) ([]string, error) {
	dir := filepath.Dir(bin)
	out := make([]string, 0, len(sources))

	for _, s := range sources {
		if !filepath.IsAbs(s) {
			snew, err := filepath.Abs(filepath.Join(dir, s))
			if err != nil {
				return nil, fmt.Errorf("unable to make %q an absolute path: %w", s, err)
			}
			s = snew
		}
		if strings.ContainsRune(s, '*') { // is glob
			matches, err := filepath.Glob(s)
			if err != nil {
				return nil, fmt.Errorf("unable to expand glob %q: %w", s, err)
			}
			GnobLogger.Debug("[gnob:rebuild] glob matches", "glob", s, "matches", matches)
			for _, m := range matches {
				out = append(out, m)
			}
			continue
		}
		out = append(out, s)
	}
	return out, nil
}

func (r Gnob_root) runBinary(ctx context.Context, binary string) error {
	GnobLogger.DebugContext(ctx, "[gnob:rebuild] executing", "binary", binary)
	cmd := exec.CommandContext(ctx, binary, os.Args[1:]...)
	cmd.Env = append(os.Environ(),
		"GNOB_REBUILD_DISABLE=1",
	)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin
	return cmd.Run()
}

func (r Gnob_root) rebuild(ctx context.Context, binary string, sources []string) error {
	GnobLogger.DebugContext(ctx, "[gnob:rebuild] rebuilding", "binary", binary)
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()
	tags := "gnob"
	if rbi, ok := debug.ReadBuildInfo(); ok {
		for _, s := range rbi.Settings {
			if s.Key == "-tags" {
				tags = s.Value
				break
			}
		}
	}
	args := []string{"build",
		"-tags", tags,
		"-o", binary,
	}
	var stderr bytes.Buffer
	args = append(args, sources...)
	cmd := exec.Command(GnobGoCommand, args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = io.MultiWriter(os.Stderr, &stderr)
	cmd.Stdin = os.Stdin
	err := cmd.Start()
	if err != nil {
		return err
	}
	go r.forwardSignals(ctx, cmd)
	if err = cmd.Wait(); err != nil {
		return fmt.Errorf("failed to build %s: %w\n%s", binary, err, stderr.String())
	}
	return nil
}

func (r Gnob_root) forwardSignals(ctx context.Context, cmd *exec.Cmd) {
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh)
	defer func() {
		signal.Stop(sigCh)
		close(sigCh)
	}()
	for {
		select {
		case <-ctx.Done():
			return
		case sig := <-sigCh:
			_ = cmd.Process.Signal(sig)
		}
	}
}

type Gnob_makefile struct {
}

// FileUpToDate returns a function that returns true if the target is up-to-date.
// The target is up-to-date if the target file is newer than all the sources.
// This can be used as the UpToDate function of a MakeTarget.
func (Gnob_makefile) FileUpToDate(target string, sources ...string) func(*GnobMakefile) bool {
	var f Gnob_files
	return func(mf *GnobMakefile) bool {
		return !f.TargetNeedsUpdate(target, sources...)
	}
}

// Makefile is a collection of targets.
// This can be used as a main function to make gnob behave like a Makefile.
type GnobMakefile struct {
	name          string
	args          []string
	commandArgs   []string
	targets       []*GnobMakeTarget
	defaultTarget int
	ctx           context.Context
}

// New construct a makefile from the given targets.
// The name of the program is taken from the first argument of os.Args.
// The argument list is taken from the second argument of os.Args.
func (m Gnob_makefile) New(targets ...GnobMakeTarget) *GnobMakefile {
	return m.NewEx(os.Args[0], os.Args[1:], targets...)
}

// NewEx is like New, but allows you to customize the name of the program and the argument list.
func (Gnob_makefile) NewEx(name string, args []string, targets ...GnobMakeTarget) *GnobMakefile {
	tgt := make([]*GnobMakeTarget, 0, len(targets))
	for i := range targets {
		tgt = append(tgt, &targets[i])
	}
	td := GnobMakefile{
		name:    name,
		args:    args,
		targets: tgt,
	}
	td.normalize()
	return &td
}

// Depend executes the targets with the given names.
// Execution is done in the order of the names.
// If any of the targets is not found, it returns an error.
// If any of the targets encounters an error, it returns the error immediately.
// If all targets are executed successfully, it returns nil.
func (mf *GnobMakefile) Depend(ctx context.Context, names ...string) error {
	if len(names) == 0 {
		return nil
	}
	targets := make([]*GnobMakeTarget, 0, len(names))
	for _, name := range names {
		found := mf.Find(name)
		if found != nil {
			targets = append(targets, found)
			continue
		}
		return fmt.Errorf("unknown target: %s", name)
	}
	for _, tgt := range targets {
		if err := tgt.exec(ctx, mf); err != nil {
			return err
		}
	}
	return nil
}

// Find returns the target with the given name.
// If the target is not found, it returns nil.
func (mf *GnobMakefile) Find(name string) *GnobMakeTarget {
	for _, tgt := range mf.targets {
		if strings.EqualFold(tgt.Name, name) {
			return tgt
		}
	}
	return nil
}

// Add adds more targets to the Makefile.
func (mf *GnobMakefile) Add(tgts ...GnobMakeTarget) {
	for _, tgt := range tgts {
		mf.targets = append(mf.targets, &tgt)
	}
	mf.normalize()
}

// TargetArgs returns the argument list for the target.
func (mf *GnobMakefile) TargetArgs() []string {
	return mf.commandArgs
}

// Run runs the target.
// If it encounters an error, it logs the error and exits with status code 1.
func (mf *GnobMakefile) Run(ctx context.Context) {
	mf.ctx = ctx
	if err := mf.RunE(ctx); err != nil {
		GnobLogger.Error("[gnob:makefile] error running build target", "error", err)
		os.Exit(1)
	}
}

// RunE runs the target and returns an error if any.
func (mf *GnobMakefile) RunE(ctx context.Context) error {
	if len(mf.args) == 0 {
		return mf.runDefault(ctx)
	}
	cmd := mf.args[0]
	mf.commandArgs = mf.args[1:]
	if cmd == "-help" {
		return mf.showHelp()
	}
	tgt := mf.Find(cmd)
	if tgt == nil {
		return fmt.Errorf("unknown target: %s", cmd)
	}
	return tgt.exec(ctx, mf)
}

func (mf *GnobMakefile) runDefault(ctx context.Context) error {
	return mf.targets[mf.defaultTarget].exec(ctx, mf)
}

func (mf *GnobMakefile) showHelp() error {
	if len(mf.commandArgs) > 0 {
		tgt := mf.Find(mf.commandArgs[0])
		if tgt == nil {
			return fmt.Errorf("unknown target: %s", mf.commandArgs[0])
		}
		return tgt.showHelp(mf)
	}
	maxLen := 0
	for _, tgt := range mf.targets {
		if tgt.Hidden {
			continue
		}
		maxLen = max(maxLen, len(tgt.Name))
	}
	fmt.Println("Usage: " + filepath.Base(mf.name) + " [-help] [target]")
	fmt.Println("Targets:")
	fmtStr := fmt.Sprintf("%%-%ds   %%s\n", maxLen)
	for i, tgt := range mf.targets {
		if tgt.Hidden {
			continue
		}
		if mf.defaultTarget == i {
			fmt.Printf("* "+fmtStr, tgt.Name, tgt.Desc)
			continue
		}
		fmt.Printf("  "+fmtStr, tgt.Name, tgt.Desc)
	}
	fmt.Println("\n* (default target)")
	return nil
}

func (mf *GnobMakefile) normalize() {
	names := make(map[string]struct{})
	normalTargets := make([]*GnobMakeTarget, 0, len(mf.targets))
	for i := range mf.targets {
		name := strings.ToLower(mf.targets[i].Name)
		if _, ok := names[name]; ok {
			GnobLogger.Warn("[gnob] duplicate target", "name", name, "index", i)
			// skip duplicate targets
			continue
		}
		normalTargets = append(normalTargets, mf.targets[i])
		names[name] = struct{}{}
	}
	slices.SortFunc(normalTargets, func(a, b *GnobMakeTarget) int {
		if a.Default {
			return -1
		}
		if b.Default {
			return 1
		}
		return strings.Compare(a.Name, b.Name)
	})
	mf.targets = normalTargets
	mf.defaultTarget = 0
	for i := range mf.targets {
		if mf.targets[i].Default {
			mf.defaultTarget = i
			break
		}
	}
}

// MakeTarget is a target that can be executed by a Makefile.
type GnobMakeTarget struct {
	// Name is the name of the target.
	Name string
	// Desc is a short description of the target.
	// It is shown when listing all targets with `gnob -help`.
	Desc string
	// LongDesc is a long description of the target.
	// It is shown when running `gnob -help <target>`.
	LongDesc string
	// Hidden is true if the target should be hidden from listing.
	Hidden bool
	// Default is true if the target is the default target.
	// Only one target can be the default target.
	Default bool
	// UpToDate is a function that returns true if the target is up-to-date.
	// If the target is up-to-date, the target will not be executed.
	UpToDate func(mf *GnobMakefile) bool
	// Body is the function that executes the target.
	// When the target is not up-to-date, this body will be executed.
	Body func(ctx context.Context, mf *GnobMakefile) error
}

// Exec executes the target.
func (mt *GnobMakeTarget) exec(ctx context.Context, mf *GnobMakefile) error {
	GnobLogger.Debug("[gnob:makefile] execute target", "target", mt.Name)
	if mt.UpToDate == nil || !mt.UpToDate(mf) {
		if err := mt.Body(ctx, mf); err != nil {
			GnobLogger.Error("[gnob:makefile] error executing target", "target", mt.Name, "error", err)
			return err
		}
		return nil
	}
	GnobLogger.Info("[gnob:makefile] target is up-to-date", "target", mt.Name)
	return nil
}

func (mt *GnobMakeTarget) showHelp(mf *GnobMakefile) error {
	GnobLogger.Debug("[gnob:makefile] show help", "target", mt.Name)
	fmt.Printf("%s %s:\n", filepath.Base(mf.name), mt.Name)
	fmt.Println()
	fmt.Println(mt.Desc)
	if mt.LongDesc != "" {
		fmt.Println(mt.LongDesc)
	}
	return nil
}

type Gnob_template struct {
}

// WriteFile executes the template and writes it to the target file, using the given data
func (t Gnob_template) WriteFile(target string, mode os.FileMode, tp *template.Template, data any) error {
	out, err := os.OpenFile(target, os.O_RDWR|os.O_CREATE|os.O_TRUNC, mode)
	if err != nil {
		return fmt.Errorf("unable to create target file %q: %w", target, err)
	}
	if err = tp.Execute(out, data); err != nil {
		_ = out.Close()
		_ = os.Remove(target)
		return fmt.Errorf("unable to execute template: %w", err)
	}
	if err = out.Close(); err != nil {
		_ = os.Remove(target)
		return fmt.Errorf("unable to close target file %q: %w", target, err)
	}
	return nil
}

// ParseText parses a Go template from the text.
func (t Gnob_template) ParseText(text string) (*template.Template, error) {
	return t.ParseTextFuncs(text, nil)
}

// ParseTextFuncs parses a Go template from the text, using an extra set of template functions.
func (t Gnob_template) ParseTextFuncs(text string, extraFuncs template.FuncMap) (*template.Template, error) {
	tt := t.newTemplate(extraFuncs)
	tt, err := tt.Parse(text)
	if err != nil {
		return nil, err
	}
	return tt, nil
}

// ParseFile parses a Go template from the given file.
func (t Gnob_template) ParseFile(templateFile string) (*template.Template, error) {
	return t.ParseFileFuncs(templateFile, nil)
}

// ParseFileFuncs parses a Go template from the given file, using an extra set of template functions.
func (t Gnob_template) ParseFileFuncs(templateFile string, extraFuncs template.FuncMap) (*template.Template, error) {
	tf, err := os.ReadFile(templateFile)
	if err != nil {
		return nil, fmt.Errorf("unable to read template file %q: %w", templateFile, err)
	}
	tt, err := t.ParseTextFuncs(string(tf), extraFuncs)
	if err != nil {
		return nil, fmt.Errorf("unable to parse template file %q: %w", templateFile, err)
	}
	return tt, nil
}

func (t Gnob_template) newTemplate(extraFuncs template.FuncMap) *template.Template {
	return template.New("").Funcs(t.funcMap()).Funcs(extraFuncs)
}

func (t Gnob_template) funcMap() template.FuncMap {
	funcMap := make(template.FuncMap)
	// includeFile loads a file by path into the template
	funcMap["includeFile"] = func(path string) (string, error) {
		fs, err := os.ReadFile(path)
		if err != nil {
			return "", fmt.Errorf("unable to read file %q: %w", path, err)
		}
		return string(fs), nil
	}
	// includeFileRegion includes a portion of a file that is surrounded by a region comment.
	funcMap["includeFileRegion"] = func(path string, region string) (string, error) {
		fd, err := os.Open(path)
		if err != nil {
			return "", fmt.Errorf("unable to open file %q: %w", path, err)
		}
		defer fd.Close()
		var sb strings.Builder
		bs := bufio.NewScanner(fd)
		var inRegion bool
		for bs.Scan() {
			if strings.Contains(bs.Text(), region) {
				inRegion = !inRegion
				if !inRegion {
					break
				}
				continue
			}
			if inRegion {
				sb.WriteString(bs.Text())
				sb.WriteRune('\n')
			}
		}
		if err = bs.Err(); err != nil {
			return "", fmt.Errorf("unable to extract region: %w", err)
		}
		return sb.String(), nil
	}
	indentInternal := func(s string, n int, skip bool) (string, error) {
		var sb strings.Builder
		bs := bufio.NewScanner(strings.NewReader(s))
		var i int
		for bs.Scan() {
			i++
			if i != 1 || !skip {
				sb.WriteString(strings.Repeat(" ", n))
			}
			sb.WriteString(bs.Text())
			sb.WriteRune('\n')
		}
		if err := bs.Err(); err != nil {
			return "", fmt.Errorf("unable to indent: %w", err)
		}
		return sb.String(), nil
	}
	// indent all lines
	funcMap["indent"] = func(n int, s string) (string, error) {
		return indentInternal(s, n, false)
	}
	// indent all lines except the first
	funcMap["nindent"] = func(n int, s string) (string, error) {
		return indentInternal(s, n, true)
	}
	// unindent strips the leading 'n' characters of whitespace from all lines
	funcMap["unindent"] = func(n int, s string) (string, error) {
		var sb strings.Builder
		bs := bufio.NewScanner(strings.NewReader(s))
		for bs.Scan() {
			text := bs.Text()
			for i, r := range text {
				if !unicode.IsSpace(r) || i >= n {
					sb.WriteString(text[i:])
					break
				}
			}
			sb.WriteRune('\n')
		}
		if err := bs.Err(); err != nil {
			return "", fmt.Errorf("unable to unindent: %w", err)
		}
		return sb.String(), nil
	}
	// prepend all lines with the given prefix string
	funcMap["prefix"] = func(prefix string, s string) (string, error) {
		var sb strings.Builder
		bs := bufio.NewScanner(strings.NewReader(s))
		for bs.Scan() {
			sb.WriteString(prefix)
			sb.WriteString(bs.Text())
			sb.WriteRune('\n')
		}
		if err := bs.Err(); err != nil {
			return "", fmt.Errorf("unable to prefix: %w", err)
		}
		return sb.String(), nil
	}
	// includeTemplate parses and executes the template, passing the given data.
	funcMap["includeTemplate"] = func(path string, data any) (string, error) {
		tt, err := t.ParseFile(path)
		if err != nil {
			return "", err
		}
		var sb strings.Builder
		if err = tt.Execute(&sb, data); err != nil {
			return "", err
		}
		return sb.String(), nil
	}
	return funcMap
}
